// Generated by CoffeeScript 1.7.1
(function() {
  var MatrixSelectionPage, PmrpcDataRepository, TestDataRepository, createMatrixPromise, dataRepository, loadFile, loadFileErrorMessage, page,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  loadFile = function(file) {
    var d, reader;
    d = $.Deferred();
    reader = new FileReader();
    reader.onload = function(event) {
      return d.resolve(reader.result);
    };
    reader.onerror = function(event) {
      return d.reject(reader.error);
    };
    reader.readAsText(file);
    return d.promise();
  };

  loadFileErrorMessage = function(error) {
    switch (error.code) {
      case error.NOT_FOUND_ERR:
        return 'File not found';
      case error.NOT_READABLE_ERR:
        return 'File not readable';
      case error.ABORT_ERR:
        return 'Read operation was aborted';
      case error.SECURITY_ERR:
        return 'File is in a locked state';
      case error.ENCODING_ERR:
        return 'The file is too long to encode in a "data://" URL';
      default:
        return 'File read error';
    }
  };

  createMatrixPromise = function(file, span) {
    return loadFile(file).done(function(result) {
      return span.html($('<pre>').css({
        border: '2px solid black'
      }).text(result));
    }).fail(function(error) {
      return span.empty().css({
        border: '2px solid red'
      }).text(loadFileErrorMessage(error));
    });
  };

  MatrixSelectionPage = (function() {
    function MatrixSelectionPage(dataRepository, messageBar) {
      this.dataRepository = dataRepository;
      this.messageBar = messageBar;
      this.userSubmits = __bind(this.userSubmits, this);
      this.dataRepositoryFailure = __bind(this.dataRepositoryFailure, this);
      this.getInputDataSuccess = __bind(this.getInputDataSuccess, this);
      this.handleFileChange = __bind(this.handleFileChange, this);
      this.run = __bind(this.run, this);
    }

    MatrixSelectionPage.prototype.run = function() {
      this.messageBar.text("Fetching data...");
      return this.dataRepository.getInputData(this.getInputDataSuccess, this.dataRepositoryFailure);
    };

    MatrixSelectionPage.prototype.handleFileChange = function(index, contents) {
      return (function(_this) {
        return function(evt) {
          var file, matrixList, span;
          contents.empty();
          matrixList = (function() {
            var _i, _len, _ref, _results;
            _ref = evt.target.files;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              file = _ref[_i];
              span = $('<div>').appendTo(contents).html($('<img>').attr({
                src: 'ajax-loader.gif'
              }));
              _results.push(createMatrixPromise(file, span));
            }
            return _results;
          })();
          return $.when.apply($, matrixList).done(function() {
            var matrices;
            matrices = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            return _this.matrices[index] = matrices;
          });
        };
      })(this);
    };

    MatrixSelectionPage.prototype.getInputDataSuccess = function(inputData) {
      var background, color1, color2, contents, element, extraValidationMessage, fileinput, forceEqualNumberMatricesPerField, i, matrixPromises, maxMatricesPerField, minMatricesPerField, multiple, submitButton, table, tr, value, values, _i, _len;
      $('#title').text(inputData.title);
      $("#field").text(inputData.field);
      values = inputData.values;
      multiple = inputData.multiple === 'true' ? true : false;
      forceEqualNumberMatricesPerField = inputData.forceEqualNumberMatricesPerField === 'true' ? true : false;
      minMatricesPerField = inputData.minMatricesPerField ? inputData.minMatricesPerField : 1;
      maxMatricesPerField = inputData.maxMatricesPerField ? inputData.maxMatricesPerField : -1;
      extraValidationMessage = inputData.extraValidationMessage ? " " + inputData.extraValidationMessage : ".";
      this.matrices = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = values.length; _i < _len; _i++) {
          element = values[_i];
          _results.push([]);
        }
        return _results;
      })();
      table = $("tbody#content");
      color1 = '#ccffcc';
      color2 = '#99ff99';
      background = color1;
      for (i = _i = 0, _len = values.length; _i < _len; i = ++_i) {
        value = values[i];
        tr = $('<tr>').css({
          background: background,
          paddingTop: '3px',
          paddingBottom: '3px'
        });
        background = background === color1 ? color2 : color1;
        tr.append($('<td>').text(value));
        fileinput = $('<input>').attr({
          type: 'file'
        }).prop({
          multiple: multiple
        });
        tr.append($('<td>').append(fileinput));
        contents = $('<td>').appendTo(tr);
        matrixPromises = [];
        fileinput.change(this.handleFileChange(i, contents));
        table.append(tr);
      }
      submitButton = $("<input type='button' value='Confirm'>");
      submitButton.button();
      submitButton.click((function(_this) {
        return function() {
          var arrFileFields, errMessage, filesPerField, index, _j, _len1;
          errMessage = "";
          filesPerField = 0;
          arrFileFields = $('input[type="file"]');
          for (index = _j = 0, _len1 = arrFileFields.length; _j < _len1; index = ++_j) {
            element = arrFileFields[index];
            if (multiple) {
              if (element.files.length < minMatricesPerField) {
                errMessage = "Please, make sure that each " + inputData.field.toLowerCase() + " has ";
                if (maxMatricesPerField < minMatricesPerField) {
                  errMessage = errMessage + minMatricesPerField + " or more matrices";
                } else if (maxMatricesPerField > minMatricesPerField) {
                  errMessage = errMessage + "between " + minMatricesPerField + " and " + maxMatricesPerField + " matrices";
                } else {
                  errMessage = errMessage + minMatricesPerField + " matri" + (minMatricesPerField==1 ? "x" : "ces");
                }
                errMessage = errMessage + extraValidationMessage;
                break;
              } else if (element.files.length > maxMatricesPerField && maxMatricesPerField > 0) {
                errMessage = "Please, make sure that each " + inputData.field.toLowerCase() + " hasn't got more than " + maxMatricesPerField + " matri" + (maxMatricesPerField==1 ? "x" : "ces");
                break;
              } else if (filesPerField !== 0 && element.files.length !== filesPerField && forceEqualNumberMatricesPerField) {
                errMessage = "Please, make sure that all the elements have the same numbers of matrices";
                break;
              } else {
                filesPerField = element.files.length;
              }
            } else if (element.files.length === 0) {
              errMessage = "Please, make sure that each " + inputData.field.toLowerCase() + " has 1 matrix.";
              break;
            }
          }
          if (errMessage !== "") {
            alert(errMessage);
            return;
          }
          submitButton.button("disable");
          return _this.userSubmits(_this.matrices);
        };
      })(this));
      $('#submit').html(submitButton);
      return this.messageBar.text(inputData.message);
    };

    MatrixSelectionPage.prototype.dataRepositoryFailure = function(message) {
      return this.messageBar.text(message);
    };

    MatrixSelectionPage.prototype.userSubmits = function(matrices) {
      this.dataRepository.putOutputData({
        matrices: matrices
      }, (function() {}), this.dataRepositoryFailure);
      return this.messageBar.text("Submitted");
    };

    return MatrixSelectionPage;

  })();

  TestDataRepository = (function() {
    function TestDataRepository() {}

    TestDataRepository.prototype.getInputData = function(onSuccess, onFailure) {
      return onSuccess({
        "unsortedStages": ["S", "x", "D", "G", "J", "V"]
      });
    };

    TestDataRepository.prototype.putOutputData = function(data, onSuccess, onFailure) {
      return onSuccess({});
    };

    return TestDataRepository;

  })();

  PmrpcDataRepository = (function() {
    function PmrpcDataRepository(destination) {
      this.destination = destination;
    }

    PmrpcDataRepository.prototype.getInputData = function(onSuccess, onFailure) {
      return pmrpc.call({
        destination: this.destination,
        publicProcedureName: "getInputData",
        params: [],
        onSuccess: function(callResult) {
          return onSuccess(callResult.returnValue);
        },
        onFailure: function(callResult) {
          return onFailure(callResult.message);
        }
      });
    };

    PmrpcDataRepository.prototype.putOutputData = function(data, onSuccess, onFailure) {
      return pmrpc.call({
        destination: this.destination,
        publicProcedureName: "reply",
        params: ["OK", data],
        onSuccess: function(callResult) {
          return onSuccess(callResult.returnValue);
        },
        onFailure: function(callResult) {
          return onFailure(callResult.message);
        }
      });
    };

    return PmrpcDataRepository;

  })();

  if ((window.File != null) && (window.FileReader != null) && (window.FileList != null)) {

  } else {
    alert('The File APIs are not fully supported in this browser.');
  }

  dataRepository = $(location).attr('search') === "?test" ? new TestDataRepository() : new PmrpcDataRepository("publish");

  page = new MatrixSelectionPage(dataRepository, $('#message'));

  $(document).ready(page.run);

}).call(this);
